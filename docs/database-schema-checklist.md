# 数据库架构与前端一致性检查清单

## 问题概述
当出现"更新失败：在 schema 缓存中找不到 'users' 的 'avatar' 列"这类错误时，通常是数据库表结构与前端代码认知不一致导致的。本文档提供检查清单，帮助快速定位和解决类似问题。

## 检查清单

### 1. 数据库表结构检查
- [ ] 确认数据库中 `users` 表结构包含所有必要字段
- [ ] 确认字段类型定义正确
- [ ] 确认字段是否可为空（NULL/NOT NULL）
- [ ] 确认字段默认值设置

### 2. 前端类型定义检查
- [ ] 检查 `src/config/supabase.ts` 中的 `Database` 类型定义
- [ ] 确保所有表字段在 `Row`、`Insert`、`Update` 类型中定义一致
- [ ] 特别关注可选字段（带?）和必需字段的区别
- [ ] 确保字段名称与数据库完全一致（大小写敏感）

### 3. 数据转换逻辑检查
- [ ] 检查 `towerDefenseService.formatUserInfo` 方法
- [ ] 确保所有字段都有正确的默认值处理
- [ ] 确保字段名称映射正确
- [ ] 特别注意 `undefined` 和空字符串（''）的区别

### 4. API 调用检查
- [ ] 检查所有更新用户信息的API调用
- [ ] 确认没有使用未定义的字段
- [ ] 确认没有使用拼写错误的字段名
- [ ] 特别注意 `avatar` 与 `avatar_url` 的使用场景

### 5. 环境一致性检查
- [ ] 确认开发、测试、生产环境的数据库结构一致
- [ ] 确认所有环境都应用了相同的数据库迁移脚本
- [ ] 确认代码部署时包含最新的类型定义

## 具体修复措施

### 字段可选性修复
确保数据库字段与类型定义的可选性一致：
```typescript
// 数据库字段可为空时
Row: {
  avatar_url?: string  // 不是必需的
}

// 数据库字段有默认值且不允许为NULL时
Row: {
  avatar_url: string   // 确保始终有值
}
```

### 数据转换增强
```typescript
// 确保所有字段都有安全的默认值
formatUserInfo(data: any): UserInfo {
  return {
    id: data.user_id || data.id || '',  // 防止undefined
    name: data.display_name || data.username || '',
    avatar: data.avatar_url || '',      // 确保总是有默认值
    avatar_url: data.avatar_url || '',
    phone: data.phone || undefined,      // 可选字段使用undefined
    // ...其他字段类似处理
  };
}
```

### 字段名称统一
1. 在前端使用统一的字段名约定
2. 确保数据库字段名与API使用一致
3. 避免前端与数据库使用不同的命名方式
4. 如有必要，创建明确的字段映射表

## 测试建议

1. **边界值测试**
   - 测试字段为null、undefined、空字符串的情况
   - 测试缺失字段的API调用

2. **类型安全测试**
   - 启用严格的TypeScript检查
   - 确保所有数据流都有正确的类型定义

3. **环境一致性测试**
   - 使用相同的数据库迁移脚本
   - 使用自动化的schema验证工具

## 长期维护建议

1. **版本控制数据库变更**
   - 所有数据库结构变更都通过SQL迁移脚本
   - 建立数据库版本管理流程

2. **自动类型生成**
   - 考虑使用工具从数据库schema自动生成TypeScript类型
   - 例如：supabase gen types typescript --project-id

3. **集成测试**
   - 建立测试套件验证数据库与代码一致性
   - 在CI/CD流程中集成这些测试

## 常见陷阱

1. **命名不一致**
   - 数据库使用snake_case，前端使用camelCase
   - 缺少明确的转换逻辑

2. **可选性不一致**
   - 数据库字段NOT NULL，但类型定义为可选
   - 数据库字段可为NULL，但类型定义为必需

3. **类型不匹配**
   - 数据库使用INTEGER，但类型定义为number
   - 数据库使用BOOLEAN，但类型定义为string

4. **环境差异**
   - 开发环境更新了数据库，但生产环境未同步
   - 本地代码使用了新字段，但部署版本较旧

## 团队协作建议

1. **代码审查重点**
   - 所有涉及数据库操作的字段变更
   - 类型定义与数据库schema的匹配

2. **变更流程**
   - 数据库变更 → 类型定义更新 → 代码修改
   - 确保这一顺序严格执行

3. **文档同步**
   - 重要的数据库结构变更及时更新文档
   - 建立数据字典或ER图

---

遵循此检查清单，可有效预防"schema缓存中找不到列"类问题，提高代码健壮性和维护性。